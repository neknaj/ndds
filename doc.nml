!doctitle{Neknaj Document Description System}->align("center")$

!description[NDDSの仕様について纏めてあります]$

>>> !title{空白}$
    空白は基本的に!defabbr("Neknaj Markup Language"){nml}テキストに記述された通りに表示されます
>>> !title{改行}$
    文字が入力されている行では、行末に!code[$]がある場合、出力で改行(!abbr{HTML}では!code[<\br>])が挿入されません
    文字が入力されていない行では、行末に!code[$]がある場合、出力で改行が挿入されます
    $
    これは、文字が入力されている場合は改行が既定、文字が入力されていない場合は改行なしが規定と考えたとき、!code[$]がある際にそれが反転すると考えることができます

>>> !title{インデント}$
    インデントによって入れ子構造を表現します
    行頭にインデントマーカーが無いとインデントは増えないため、行頭の空白なども正しく扱えます
    インデントは全て4文字の文字列によって開始され、改行後4つの空白がインデントとなります　改行後空白が4つ以下になるとその手前の行までが子となります
    nmlの最後の行がインデントされていたとしても、入れ子は自動的に閉じられます
    >>> !title{インデントマーカー}$
        !code[>>> ] ・・・ nmlの入れ子を表します
        >>> 子はHTMLに変換された際、nestというclassが付いたdivに格納されます
        その為、HTML上でもこのインデントによる入れ子の構造が明示され、確認することができます
        !code[>>$ ] ・・・ 関数のブロック呼び出しを表します
        >>> 子の関数呼び出しからの返り値がそのままHTMLに入ります
        !code[<<= ] ・・・ 関数のブロック呼び出しに於ける文字列引数を表します
        >>> 子の内容がそのまま関数に渡されます
        !code[<<< ] ・・・ 関数のブロック呼び出しに於けるnml引数を表します
        >>> 子の内容がそのまま関数に渡されます

>>> !title{関数呼び出し}$
    モジュールで定義したJavascriptの関数を呼び出せます
    >>> !title{インライン呼び出し}$
        文中に現れる要素を呼び出します　テキストの中に書くことができます
        !code[!名前(引数1,引数2,...)[文字列引数1\][文字列引数2\]...{nml引数1\}{nml引数2\}...]の形で呼び出します
        普通の引数も文字列引数もnml引数も改行できません
        引数と文字列引数とnml引数は省略できます
        文字列引数とnml引数の順序は自由ですが、普通の引数は必ず名前の直後に来なければなりません
        JavaScriptからは、(文字列引数nml引数の配列,引数1,引数2)のように見えます
        nml引数はHTMLへ変換された後のものが配列に入ります　文字列引数はそのままの文字列が配列に入ります
        配列には呼び出した時の順に入ります
    >>> !title{ブロック呼び出し}$
        文中ではなく独立して存在する要素を呼び出します　呼び出し自体が一つのインデントになる為、テキストの中に書くことはできません
        普通の引数は改行できません
        ブロック引数は改行できます
        引数とブロック引数は省略できます
        JavaScriptからは、(文字列引数nml引数の配列,引数1,引数2)のように見えます
        nml引数はHTMLへ変換された後のものが配列に入ります　文字列引数はそのままの文字列が配列に入ります
        配列には呼び出した時の順に入ります
        >>> !title{ブロック引数}$
            ブロック引数は改行することができます
            ブロック引数には文字列引数とnml引数があります
    >>> !title{チェーン呼び出し}$
        関数の返り値をさらに加工します
        関数呼び出しの入れ子よりも簡潔に書くことができます
        !code[前の関数呼び出し()->名前(引数1,引数2,...)]の形で呼び出します
        JavaScriptからは、(前の関数の返り値,引数1,引数2)のように見えます
        ブロック呼び出しでは、呼び出し一行目末尾に!code[->名前(引数1,引数2,...)]と書きます つまり、チェーン呼び出しはブロック引数の前に記述します
        ただし、記述された順とは変わりますが、チェーン呼び出しの評価はブロック呼び出しの評価が全て終わった後に行います
    >>> !title{引数}$
        これは!code[{}]や!code[[\]]に囲われているnml引数や文字列引数ではない、!code[()]に囲われている引数についての項目です
        $
        引数は数値・文字列・関数呼び出し・nullの何れかです
        $
        文字列は!code[""]で囲って下さい　文字列中に現れる!code["]は!code[\\"]とエスケープして下さい
        関数呼び出しはインライン呼び出しのみが可能です　これは引数が改行できない為です
        nullは規定値を使用する時などに使用できます
    nml引数と文字列引数が内容となり、普通の引数は設定用として用いられることを推奨します

>>> !title{モジュール}$
    nmlから呼び出すJavaScriptの関数や、ブラウザで表示する際に適用されるスタイルシートは、モジュールとして定義されており、これは簡単に追加・編集できます
    モジュールは!code[/modules]の中に入れ、!code[/modules/modules.json]に一覧を記述する必要があります
    これらは!code[js]、!code[style]、!code[theme]に分けて、!code[/modules/]からの相対パスで記述してください
    $
    !code[style]と!code[theme]は両方とも!abbr{CSS}ファイルですが、!code[theme]はnmlを表示しているHTMLページ全体に適用されるのに対し、!code[style]はnmlだけの隔離された範囲に適用されるため、双方適切に設定する必要があります
    >>> !title{js}$
        nmlのjsモジュールは、JavaScriptのES Moduleとして読み込まれます 以下これをNML Moduleと呼びます
        >>> NML Moduleは、nmlのソースコードから直接呼出す関数を記述したモジュールのことです
            NML Moduleから呼び出すライブラリはES Moduleかもしれませんが、NML Moduleではありません
            !code[/modules]にはNML Moduleでないjsファイルを入れて構いませんが、!code[modules.json]にはNML Moduleのみ記述してください
        NML Moduleでは一般のES Moduleと同様に、import文を使用して他のES Moduleを読み込むことができます
        NML Moduleではexportを、nmlから呼び出す関数を出力するために用います
        exportする内容はInline,Block,Chainと名付けられた3つの連想配列です
        これらの連想配列にはnmlから呼び出される関数のみを入れてください
        呼び出される関数の記述は、前述した関数呼び出しの項を参考にして下さい